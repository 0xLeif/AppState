# Вопросы миграции

При обновлении вашей модели данных, особенно для сохраненных или синхронизированных данных, вам необходимо обеспечить обратную совместимость, чтобы избежать потенциальных проблем при загрузке старых данных. Вот несколько важных моментов, которые следует учитывать:

## 1. Добавление необязательных полей
Если вы добавляете в свою модель новые необязательные поля, декодирование старых данных (которые не будут содержать эти поля) может завершиться неудачей. Чтобы избежать этого:
- Рассмотрите возможность присвоения новым полям значений по умолчанию.
- Сделайте новые поля необязательными, чтобы обеспечить совместимость со старыми версиями вашего приложения.

### Пример:
```swift
struct Settings: Codable {
    var text: String
    var isDarkMode: Bool
    var newField: String? // Новое поле является необязательным
}
```

## 2. Изменения формата данных
Если вы изменяете структуру модели (например, меняете тип с `Int` на `String`), процесс декодирования может завершиться неудачей при чтении старых данных. Спланируйте плавную миграцию:
- Создав логику миграции для преобразования старых форматов данных в новую структуру.
- Используя настраиваемый инициализатор `Decodable` для обработки старых данных и их сопоставления с вашей новой моделью.

### Пример:
```swift
struct Settings: Codable {
    var text: String
    var isDarkMode: Bool
    var version: Int

    // Пользовательская логика декодирования для старых версий
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.text = try container.decode(String.self, forKey: .text)
        self.isDarkMode = try container.decode(Bool.self, forKey: .isDarkMode)
        self.version = (try? container.decode(Int.self, forKey: .version)) ?? 1 // Значение по умолчанию для старых данных
    }
}
```

## 3. Обработка удаленных или устаревших полей
Если вы удаляете поле из модели, убедитесь, что старые версии приложения все еще могут декодировать новые данные без сбоев. Вы можете:
- Игнорировать лишние поля при декодировании.
- Использовать настраиваемые декодеры для обработки старых данных и правильного управления устаревшими полями.

## 4. Версионирование ваших моделей

Версионирование ваших моделей позволяет вам управлять изменениями в вашей структуре данных с течением времени. Сохраняя номер версии как часть вашей модели, вы можете легко реализовать логику миграции для преобразования старых форматов данных в новые. Такой подход гарантирует, что ваше приложение сможет обрабатывать старые структуры данных, плавно переходя на новые версии.

- **Почему версионирование важно**: когда пользователи обновляют свое приложение, у них все еще могут быть сохраненные на устройствах старые данные. Версионирование помогает вашему приложению распознавать формат данных и применять правильную логику миграции.
- **Как использовать**: добавьте поле `version` в свою модель и проверяйте его во время процесса декодирования, чтобы определить, требуется ли миграция.

### Пример:
```swift
struct Settings: Codable {
    var version: Int
    var text: String
    var isDarkMode: Bool

    // Обработка логики декодирования для конкретной версии
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.version = try container.decode(Int.self, forKey: .version)
        self.text = try container.decode(String.self, forKey: .text)
        self.isDarkMode = try container.decode(Bool.self, forKey: .isDarkMode)

        // При миграции со старой версии примените необходимые преобразования здесь
        if version < 2 {
            // Миграция старых данных в новый формат
        }
    }
}
```

- **Лучшая практика**: начинайте с поля `version` с самого начала. Каждый раз, когда вы обновляете структуру своей модели, увеличивайте версию и обрабатывайте необходимую логику миграции.

## 5. Тестирование миграции
Всегда тщательно тестируйте свою миграцию, имитируя загрузку старых данных с новыми версиями вашей модели, чтобы убедиться, что ваше приложение ведет себя так, как ожидалось.
