# AppState का उन्नत उपयोग

यह गाइड **AppState** का उपयोग करने के लिए उन्नत विषयों को कवर करती है, जिसमें जस्ट-इन-टाइम निर्माण, निर्भरताओं को प्रीलोड करना, स्थिति और निर्भरताओं का प्रभावी ढंग से प्रबंधन करना, और **AppState** की तुलना **SwiftUI के पर्यावरण** से करना शामिल है।

## 1. जस्ट-इन-टाइम निर्माण

AppState मान, जैसे `State`, `Dependency`, `StoredState`, और `SyncState`, जस्ट-इन-टाइम बनाए जाते हैं। इसका मतलब है कि वे केवल पहली बार एक्सेस किए जाने पर ही इंस्टैंशिएट होते हैं, जिससे आपके एप्लिकेशन की दक्षता और प्रदर्शन में सुधार होता है।

### उदाहरण

```swift
extension Application {
    var defaultState: State<Int> {
        state(initial: 0) // मान तब तक नहीं बनाया जाता जब तक इसे एक्सेस नहीं किया जाता
    }
}
```

इस उदाहरण में, `defaultState` पहली बार एक्सेस किए जाने तक नहीं बनाया जाता है, जिससे संसाधन उपयोग का अनुकूलन होता है।

## 2. निर्भरताओं को प्रीलोड करना

कुछ मामलों में, आप कुछ निर्भरताओं को प्रीलोड करना चाह सकते हैं ताकि यह सुनिश्चित हो सके कि वे आपके एप्लिकेशन के शुरू होने पर उपलब्ध हैं। AppState एक `load` फ़ंक्शन प्रदान करता है जो निर्भरताओं को प्रीलोड करता है।

### उदाहरण

```swift
extension Application {
    var databaseClient: Dependency<DatabaseClient> {
        dependency(DatabaseClient())
    }
}

// ऐप इनिशियलाइज़ेशन में प्रीलोड करें
Application.load(dependency: \.databaseClient)
```

इस उदाहरण में, `databaseClient` ऐप के इनिशियलाइज़ेशन के दौरान प्रीलोड किया जाता है, यह सुनिश्चित करता है कि यह आपके दृश्यों में आवश्यकता होने पर उपलब्ध है।

## 3. स्थिति और निर्भरता प्रबंधन

### 3.1 पूरे एप्लिकेशन में साझा स्थिति और निर्भरताएँ

आप अपने ऐप के एक हिस्से में साझा स्थिति या निर्भरताएँ परिभाषित कर सकते हैं और अद्वितीय आईडी का उपयोग करके दूसरे हिस्से में उन तक पहुँच सकते हैं।

### उदाहरण

```swift
private extension Application {
    var stateValue: State<Int> {
        state(initial: 0, id: "stateValue")
    }

    var dependencyValue: Dependency<SomeType> {
        dependency(SomeType(), id: "dependencyValue")
    }
}
```

यह आपको उसी `State` या `Dependency` को कहीं और उसी आईडी का उपयोग करके एक्सेस करने की अनुमति देता है।

```swift
private extension Application {
    var theSameStateValue: State<Int> {
        state(initial: 0, id: "stateValue")
    }

    var theSameDependencyValue: Dependency<SomeType> {
        dependency(SomeType(), id: "dependencyValue")
    }
}
```

हालांकि यह दृष्टिकोण एक ही स्ट्रिंग `id` का पुन: उपयोग करके पूरे एप्लिकेशन में स्थिति और निर्भरताओं को साझा करने के लिए मान्य है, इसे आम तौर पर हतोत्साहित किया जाता है। यह इन स्ट्रिंग आईडी के मैन्युअल प्रबंधन पर निर्भर करता है, जिससे हो सकता है:
- आकस्मिक आईडी टकराव यदि एक ही आईडी का उपयोग विभिन्न इच्छित स्थितियों/निर्भरताओं के लिए किया जाता है।
- यह ट्रैक करने में कठिनाई कि स्थिति/निर्भरता कहाँ परिभाषित है बनाम कहाँ एक्सेस की गई है।
- कोड स्पष्टता और रखरखाव में कमी।
एक ही आईडी के साथ बाद की परिभाषाओं में प्रदान किया गया `initial` मान अनदेखा कर दिया जाएगा यदि स्थिति/निर्भरता को उसके पहले एक्सेस द्वारा पहले ही प्रारंभ कर दिया गया है। यह व्यवहार AppState में आईडी-आधारित कैशिंग के काम करने के तरीके का एक साइड इफेक्ट है, बजाय साझा डेटा को परिभाषित करने के लिए एक अनुशंसित प्राथमिक पैटर्न के। `Application` एक्सटेंशन में स्थितियों और निर्भरताओं को अद्वितीय संगणित गुणों के रूप में परिभाषित करना पसंद करें (जो स्वचालित रूप से अद्वितीय आंतरिक आईडी उत्पन्न करते हैं यदि फ़ैक्टरी विधि को कोई स्पष्ट `id` प्रदान नहीं किया जाता है)।

### 3.2 प्रतिबंधित स्थिति और निर्भरता पहुँच

पहुँच को प्रतिबंधित करने के लिए, UUID जैसी एक अद्वितीय आईडी का उपयोग करें ताकि यह सुनिश्चित हो सके कि ऐप के केवल सही हिस्से ही विशिष्ट स्थितियों या निर्भरताओं तक पहुँच सकते हैं।

### उदाहरण

```swift
private extension Application {
    var restrictedState: State<Int?> {
        state(initial: nil, id: UUID().uuidString)
    }

    var restrictedDependency: Dependency<SomeType> {
        dependency(SomeType(), id: UUID().uuidString)
    }
}
```

### 3.3 स्थितियों और निर्भरताओं के लिए अद्वितीय आईडी

जब कोई आईडी प्रदान नहीं की जाती है, तो AppState स्रोत कोड में स्थान के आधार पर एक डिफ़ॉल्ट आईडी उत्पन्न करता है। यह सुनिश्चित करता है कि प्रत्येक `State` या `Dependency` अद्वितीय है और अनपेक्षित पहुँच से सुरक्षित है।

### उदाहरण

```swift
extension Application {
    var defaultState: State<Int> {
        state(initial: 0) // AppState एक अद्वितीय आईडी उत्पन्न करता है
    }

    var defaultDependency: Dependency<SomeType> {
        dependency(SomeType()) // AppState एक अद्वितीय आईडी उत्पन्न करता है
    }
}
```

### 3.4 फ़ाइल-निजी स्थिति और निर्भरता पहुँच

एक ही स्विफ्ट फ़ाइल के भीतर और भी अधिक प्रतिबंधित पहुँच के लिए, स्थितियों और निर्भरताओं को बाहरी रूप से एक्सेस किए जाने से बचाने के लिए `fileprivate` एक्सेस स्तर का उपयोग करें।

### उदाहरण

```swift
fileprivate extension Application {
    var fileprivateState: State<Int> {
        state(initial: 0)
    }

    var fileprivateDependency: Dependency<SomeType> {
        dependency(SomeType())
    }
}
```

### 3.5 AppState के संग्रहण तंत्र को समझना

AppState `State`, `Dependency`, `StoredState`, और `SyncState` को संग्रहीत करने के लिए एक एकीकृत कैश का उपयोग करता है। यह सुनिश्चित करता है कि ये डेटा प्रकार आपके पूरे ऐप में कुशलतापूर्वक प्रबंधित किए जाते हैं।

डिफ़ॉल्ट रूप से, AppState "App" के रूप में एक नाम मान निर्दिष्ट करता है, जो यह सुनिश्चित करता है कि एक मॉड्यूल से जुड़े सभी मान उस नाम से बंधे हैं। यह इन स्थितियों और निर्भरताओं को अन्य मॉड्यूलों से एक्सेस करना कठिन बना देता है।

## 4. AppState बनाम SwiftUI का पर्यावरण

AppState और SwiftUI का पर्यावरण दोनों आपके एप्लिकेशन में साझा स्थिति और निर्भरताओं के प्रबंधन के तरीके प्रदान करते हैं, लेकिन वे दायरे, कार्यक्षमता और उपयोग के मामलों में भिन्न होते हैं।

### 4.1 SwiftUI का पर्यावरण

SwiftUI का पर्यावरण एक अंतर्निहित तंत्र है जो आपको एक दृश्य पदानुक्रम के माध्यम से साझा डेटा पास करने की अनुमति देता है। यह उन डेटा को पास करने के लिए आदर्श है जिनकी कई दृश्यों को पहुँच की आवश्यकता होती है, लेकिन अधिक जटिल स्थिति प्रबंधन की बात आने पर इसकी सीमाएँ होती हैं।

**ताकत:**
- उपयोग करने में सरल और SwiftUI के साथ अच्छी तरह से एकीकृत।
- हल्के डेटा के लिए आदर्श जिसे एक पदानुक्रम में कई दृश्यों में साझा करने की आवश्यकता होती है।

**सीमाएं:**
- डेटा केवल विशिष्ट दृश्य पदानुक्रम के भीतर ही उपलब्ध है। अतिरिक्त काम के बिना विभिन्न दृश्य पदानुक्रमों में समान डेटा तक पहुँचना संभव नहीं है।
- AppState की तुलना में थ्रेड सुरक्षा और दृढ़ता पर कम नियंत्रण।
- अंतर्निहित दृढ़ता या सिंक्रनाइज़ेशन तंत्र की कमी।

### 4.2 AppState

AppState पूरे एप्लिकेशन में स्थिति के प्रबंधन के लिए एक अधिक शक्तिशाली और लचीला सिस्टम प्रदान करता है, जिसमें थ्रेड सुरक्षा, दृढ़ता और निर्भरता इंजेक्शन क्षमताएं हैं।

**ताकत:**
- केंद्रीकृत स्थिति प्रबंधन, पूरे ऐप में सुलभ, न कि केवल विशिष्ट दृश्य पदानुक्रमों में।
- अंतर्निहित दृढ़ता तंत्र (`StoredState`, `FileState`, और `SyncState`)।
- प्रकार सुरक्षा और थ्रेड सुरक्षा गारंटी, यह सुनिश्चित करना कि स्थिति को सही ढंग से एक्सेस और संशोधित किया गया है।
- अधिक जटिल स्थिति और निर्भरता प्रबंधन को संभाल सकता है।

**सीमाएं:**
- SwiftUI के पर्यावरण की तुलना में अधिक सेटअप и कॉन्फ़िगरेशन की आवश्यकता है।
- पर्यावरण की तुलना में SwiftUI के साथ कुछ हद तक कम एकीकृत, हालांकि अभी भी SwiftUI ऐप्स में अच्छा काम करता है।

### 4.3 प्रत्येक का उपयोग कब करें

- **SwiftUI का पर्यावरण** का उपयोग तब करें जब आपके पास सरल डेटा हो जिसे एक दृश्य पदानुक्रम में साझा करने की आवश्यकता हो, जैसे उपयोगकर्ता सेटिंग्स या थीमिंग प्राथमिकताएँ।
- **AppState** का उपयोग तब करें जब आपको केंद्रीकृत स्थिति प्रबंधन, दृढ़ता, या अधिक जटिल स्थिति की आवश्यकता हो जिसे पूरे ऐप में एक्सेस करने की आवश्यकता हो।

## निष्कर्ष

इन उन्नत तकनीकों का उपयोग करके, जैसे कि जस्ट-इन-टाइम निर्माण, प्रीलोडिंग, स्थिति और निर्भरता प्रबंधन, और AppState और SwiftUI के पर्यावरण के बीच के अंतर को समझकर, आप **AppState** के साथ कुशल और संसाधन-सचेत एप्लिकेशन बना सकते हैं।
